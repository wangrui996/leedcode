# KMP算法  

解决经典的字符串匹配问题  


[KMP算法详解](https://www.zhihu.com/question/21923021)


## 问题描述  

假设一个文本串s = "aabaabaaf"   一个模式串 sub =  "aabaaf"  问文本串中含不含模式串  

##　暴力解法　　




## KMP算法  

对于一个模式串sub  
**前缀：** 模式串中包含首字母但不包含尾字母的所有字串 对于这个模式串，就是a  aa  aab  aaba  aabaa 五个
**后缀：** 模式串中包含尾字母但不包含首字母的所有字串，对于这个模式串，是f  af  aaf   baaf  abaaf 五个  

**最长相等前后缀** ：就是求最长 相等的前后缀    

那么，对于模式串sub，它的所有字串的最长相等前后缀长度分别是多少？

* a：     0    它的最长相等前后缀 0  
* aa ：   1    前缀a  后缀a
* aab :   0  
* aaba :  1  
* aabaa : 2
* aabaaf : 0

**模式串的前缀表** ：010120  即使各个子串的最长相等前后缀长度组成的序列    

###　使用前缀表进行匹配　　

1.从文本串s首字符开始与模式串匹配，当遇到某个不匹配字符时，查找该字符之前部分的模式串的最长相等前后缀是多少，如下面情况，当模式串中f与文本串中b不匹配时，模式串前面的字串中(aabaa),拥有的最长相等前后缀长度是2，2意味着，aabaa中前面个2字符前缀和后面的2字符前缀相等(在这里是aa)
aabaabaaf  
aabaaf
     ^
010120

2.找到了最长相等前后缀长度后，我们实际上是可以将模式串向后移动，将最长相等前后缀的前缀移动到后缀位置，同时当前继续从刚才指针停的位置继续比较 ；但注意，我们写代码时，指针是可以移动的，但是字符串没法在内存中像下面那样向后移动来与上面的文本串重新保持有一部分对齐(时间和空间成本大)   
aabaabaaf  
   aabaaf 
     ^

3.因此我们在设置指针的时候，移动的是模式串中的指针  
当得到模式串一个位置与文本串不匹配时，去看它的前一位在前缀表中的值，得到它前面的子串(aabaa)的最长相等前后缀长度2   此时我们根据2的思路可以知道，只需要继续比较模式串中b的字符和刚才文本串中的位置，这个**模式串中要移动到的新的位置对应的索引是2，正好等于最长相等前后缀长度2**  

**next数组** ： **前缀表，它告诉我们在遇到冲突时应该回退到哪里**


4.前缀表怎么求：代码部分  next数组保存  

* next数组保存的是前缀表本身  当遇到冲突时，根据模式串冲突字符的前一个字符对应的前缀表中的值，决定要移动到的新的位置，上面这个例子就是2  

* next数组是前缀表向右移动一位，首位置为-1，遇到冲突时，直接取冲突位置对应的前缀表值  next [-11012]  

* next数组是原前缀表减1  next [-1 0 -1 0 1 -1]  还是看冲突位置的前一位，但是会把前一位值加上1   

总之**next数组解决**的就是**遇到冲突以后回退的位置**


5.next




### 个人理解

kmp算法关键在于：在当前对文本串和模式串检索的过程中，若出现了不匹配，如何充分利用已经匹配的部分。

匹配到不正确的地方以前的子串跟上面的子串相等所以下面的子串的最长前缀肯定跟上面最长子串的后缀有匹配。  




## KMP代码  


### 求解next数组  

对于一个模式串s

1.初始化  

* 定义两个指针i和j， j指向前缀起始位置，初始化为0   i指向后缀起始位置，从i遍历到s.size() - 1;(后缀起始位置范围就是[1, s.size()-1])  

* next数组初始化  next[0] = j;


2.处理前后缀不相同的情况  

也就是 s[i] != s[j] ： 此时j要回退，回退的位置是查询next[j-1]，但是不止回退一次，要一直循环，但是j为0的时候，next[j-1]会越界，因此while循环条件还要加个j > 0    

**就是说：** 遇到不相等情况，j一直回退到0位置或者到他俩相同的地方  

3.处理前后缀相同的情况
上面循环结束后，判断是否相等，因为上面的循环可能因为是s[i] == s[j]停下，也可能是因为j==0停下了，此时s[i]和是s[j]不知道是否相等  

if(s[i] == s[j]) : 说明找到了相同前后缀，同时向后移动i和j，因为i在for循环会移动所以循环体里面只要 j++;  

4.next数组赋值  

处理完上述两种情况后，要对next数组进行赋值  next[i] = j;

```cpp
void getNext(int* next, const string& s) {
    int j = 0;
    next[0] = 0;
    for(int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
            j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```  


### 匹配  

1.定义两个下表i，j分别指向文本串s和模式串sub起始位置  

i从0开始循环遍历文本串  

```cpp 
for (int i = 0; i < s.size(); i++)
```

2.循环比较s[i]与sub[j]  直接两者相等或j退回到0处  

* 如果s[i] != sub[j]  **j就要回退寻找下一个匹配的位置，这是KMP算法的核心**，回退位置是从next[j-1]处找，那么仍然是注意j > 0否则j等于0了但是s[i] != sub[j]，导致next[j-1]越界  

3.判断s[i] 是否等于 sub[j]  
while循环结束后:  

* if(s[i] == sub[j])  j++  i也要向后移动只不过在for循环做  

4.判断文本串s中是否出现了模式串sub  

如果j指向了模式串的末尾，说明模式串sub完全匹配了文本串s中的某个子串  

也就是j == sub.size() - 1时，s[i] == sub[j]  因为此时j要++，所以最后判断的是j是否等于sub.size(),等于就说明匹配成功  

此时，我们返回(或者)文本串中匹配子串出现的首位置，即 return (i - sub.size() + 1)  



```cpp
int strStr(string s, string sub) {
    if (sub.size() == 0) {
        return 0;
    }
    int next[sub.size()];
    getNext(next, sub);
    int j = 0;
    for (int i = 0; i < s.size(); i++) {
        while(j > 0 && s[i] != sub[j]) {
            j = next[j - 1];
        }
        if (s[i] == sub[j]) {
            j++;
        }
        if (j == sub.size()) {
            return (i - sub.size() + 1);
        }
    }
    return -1;
}
```


## 总结   

先是暴力解————>时间复杂度太高，想办法优化————>每一次匹配失败，假设发生文本串s的r+1处，那么s[i]到s[r-1]和模式串某个前缀是相等的————>暴力解法是再从s[i+1]处，模式串的j从0处重新依次比较—————>实际上通过举例发现，s[i+1]与sub[0]可能根本不相等，是没有必要从i+1处开始的  

**一个简单的想法是，起码让i向后移动到s[i]和sub[0]相等**  进而考虑，此时s[i+1]和sub[1]就相等吗，不一定     


**问题的关键在于：当发生冲突时，怎样利用已经失败的信息**

***继续分析** ： 如下图  在i=5处发生了匹配失败，此时我们有个**重要信息**是**前面的匹配成功的串**   

![image](https://user-images.githubusercontent.com/58176267/157580463-51574a92-f450-4589-b044-0de270f958c3.png)





我们试着移动一下i  i等于0开始匹配，发现在i=5时冲突，那么令i=1，j=0重新匹配，





