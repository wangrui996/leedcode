# 0153. 寻找旋转排序数组中的最小值

[力扣题目链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)   


## 题目描述  

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 **旋转** 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：    
* 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]  
* 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]  

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] **旋转一次** 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。  

给你一个元素值 **互不相同** 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。  

 
**示例 1：**

    输入：nums = [3,4,5,1,2]
    输出：1
    解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

**示例 2：**

    输入：nums = [4,5,6,7,0,1,2]
    输出：0
    解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

**示例 3：**

    输入：nums = [11,13,15,17]
    输出：11
    解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
 

**提示：**

    n == nums.length
    1 <= n <= 5000
    -5000 <= nums[i] <= 5000
    nums 中的所有整数 互不相同
    nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转


## 思路分析  

* 1.旋转数组在旋转前是**升序**的，旋转后（假设至少旋转1次）被分成了两个升序数组  
* 2.数组中元素**互不相同**是很重要的一个点  
* 3.排序数组想到用**二分**  
* 4.参考[官方题解](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/)的图
与[题解](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/)  

* 一个升序数组被分成了两个升序数组  
* 二分法的左界left初始化为第一部分升序区间的左边界（也就是nums[0]）,右界初始化为第二部分升序区间的右边界（也就是nums[nums.size() - 1]）  
* 比较nums[mid]与nums[right]、nums[left]的值有几种情况 
    * 1.nums
    * 2.

    
## 方法1 二分   

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        int mid = 0;
        if(nums[left] < nums[right])return nums[0];
        while(left < right)
        {
            mid = left + (right - left) / 2;
            //因为mid计算的时候(right - left)除以2是向下取整的，因此更靠近left
            //mid不会等于right，只可能等于left        
            if(nums[mid] > nums[right])
            {
                left = mid + 1; //这里mid + 1如果导致left进入第二部分升序区间，后面判断nums[mid] > nums[right]一定不满足，因此进入else语句中，即认为此时nums[mid]位于第二部分升序区间，之后缩小右边界，是可以的
                //也就是后面mid还是可能取到left即最小值的索引
            }
            else //也可以具体点 else if(nums[mid] < nums[right])
            {
                right = mid; //这里因为right如果等于mid - 1.当mid - 1导致right进入第一部分升序区间后，后面由left和right时求得mid不可能等于right，因此最小值无法被取到；而且后面明明已经进入第一部分升序区间，但由于nums[mid] < nums[right]成立，因此会被认为还是第二部分升序区间，继续缩小右边界，导致最小值越来越远  
            }
        }
        return nums[right];

    }
};
```


